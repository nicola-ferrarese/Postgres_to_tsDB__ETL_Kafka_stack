# Generated by Django 4.1.2 on 2022-10-17 09:35

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True
    DjangoApp = 'envsensor'
    name = 'env_measure'
    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='env_measure_30min',
            fields=[
                ('device_id', models.IntegerField()),
                ('timestamp', models.DateTimeField(primary_key=True, serialize=False)),
                ('air_temp', models.FloatField()),
                ('id', models.IntegerField()),
                ('air_pres', models.FloatField()),
                ('air_hum', models.FloatField()),
            ],
            options={
                'db_table': 'envsensor_view_30min',
                'managed': False,
            },
        ),
        migrations.CreateModel(
            name='env_measure',
            fields=[
                ('device_id', models.IntegerField()),
                ('timestamp', models.DateTimeField(primary_key=True, serialize=False)),
                ('air_temp', models.FloatField()),
                ('id', models.IntegerField()),
                ('air_pres', models.FloatField()),
                ('air_hum', models.FloatField()),
            ],

        ),

        ##
        ## Dropping Primary Key Constraints because we create hypertable
        ##
        migrations.RunSQL(
            f"ALTER TABLE {DjangoApp}_{name} DROP CONSTRAINT {DjangoApp}_{name}_pkey;"
        ),
        ## Create Hypertable
        migrations.RunSQL(
            f"SELECT create_hypertable('{DjangoApp}_{name}', 'timestamp', chunk_time_interval => INTERVAL '7 days');"
        ),
        ## Set unique constraint to allow UPSERT of data
        migrations.RunSQL(
            f"ALTER TABLE {DjangoApp}_{name} ADD CONSTRAINT const_time_is UNIQUE (timestamp, id);"
        ),
        ## Create aggregate view (30 min)
        migrations.RunSQL(
            "CREATE MATERIALIZED VIEW envsensor_view_30min(timestamp, air_temp, air_pres, air_hum) "
            "WITH(timescaledb.continuous) AS "
            f"SELECT time_bucket('30 minutes', timestamp) as timestamp, "
            f"avg(air_temp) as air_temp,"
            f"avg(air_pres) as air_pres,"
            f"avg(air_hum) as air_hum "
            f"FROM {DjangoApp}_{name} "
            "GROUP BY time_bucket('30 minutes', timestamp) WITH NO DATA;"
        ),
        ## Set timespan of the single chunk
        migrations.RunSQL(
            "SELECT set_chunk_time_interval("
            "(SELECT "
            ## https://github.com/timescale/docs/blob/latest/timescaledb/how-to-guides/continuous-aggregates/materialized-hypertables.md
            "format('%I.%I', materialization_hypertable_schema, materialization_hypertable_name) AS materialization_hypertable "
            "FROM timescaledb_information.continuous_aggregates "
            "where view_name='envsensor_view_30min')::regclass, INTERVAL '4 days');"
        ),
        ## Set policy to refresh aggregate:
        # look between 1 day and 1 minute ago and create aggregate,
        # do so every shedule interval
        migrations.RunSQL(
            "SELECT add_continuous_aggregate_policy('envsensor_view_30min',"
            "start_offset => INTERVAL '1 day',"
            "end_offset => INTERVAL '1 min',"
            "schedule_interval => INTERVAL '3 minutes');"
        ),

        ## Keep raw data for 30 day, then drop
        migrations.RunSQL(
            f"SELECT add_retention_policy('{DjangoApp}_{name}', INTERVAL '30 days');"
        ),


    ]
